<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Infinity ♾️ Wallet — Phantom Style</title>
<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
<script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.js"></script>
<script src="https://unpkg.com/qrcode@1.5.0/build/qrcode.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cryptocurrency-icons@0.18.1/svg/color/generic.css" />

<style>
  :root {
    --bg: #04040d;
    --card: #0f0f1a;
    --muted: #a5a5c3;
    --accent: #7e57c2;
    --accent-hover: #9575cd;
    --danger: #ff5252;
    --success: #4caf50;
    --border: rgba(255,255,255,0.05);
    --input-bg: #1a1a2e;
  }
  body { margin: 0; background: var(--bg); color: #fff; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; padding: 20px; }
  .wrap { max-width: 1000px; margin: 0 auto; }
  .card { background: var(--card); padding: 16px; border-radius: 12px; margin-bottom: 16px; border: 1px solid var(--border); box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
  h1 { margin: 0 0 12px; font-size: 24px; color: var(--accent); }
  input, select, textarea { width: 100%; padding: 12px; border-radius: 8px; background: var(--input-bg); border: 1px solid var(--border); color: #fff; font-size: 14px; }
  input:focus, select:focus { outline: none; border-color: var(--accent); }
  button { padding: 12px 16px; border-radius: 8px; border: none; cursor: pointer; background: var(--accent); color: #fff; font-weight: 600; transition: background 0.2s; }
  button:hover { background: var(--accent-hover); }
  button.ghost { background: transparent; border: 1px solid var(--border); color: var(--muted); }
  button.ghost:hover { border-color: var(--accent); color: var(--accent); }
  button.danger { background: var(--danger); }
  .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
  .small { color: var(--muted); font-size: 13px; }
  .danger { color: var(--danger); }
  .success { color: var(--success); }
  .hidden { display: none; }
  .mn-grid { display: grid; grid-template-columns: repeat(3,1fr); gap: 12px; margin-top: 12px; }
  .mn-cell { background: var(--input-bg); padding: 12px; border-radius: 8px; border: 1px solid var(--border); font-weight: 600; text-align: center; }
  .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; padding: 16px; z-index: 1000; }
  .modal-card { background: var(--card); padding: 20px; border-radius: 16px; max-width: 800px; width: 100%; box-shadow: 0 4px 20px rgba(0,0,0,0.3); }
  .muted { color: var(--muted); }
  pre { background: rgba(255,255,255,0.03); padding: 12px; border-radius: 8px; color: #d1e4ff; overflow: auto; font-size: 13px; }
  .loader { border: 2px solid var(--accent); border-top: 2px solid transparent; border-radius: 50%; width: 16px; height: 16px; animation: spin 1s linear infinite; display: inline-block; margin-left: 8px; }
  @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
  .icon { width: 24px; height: 24px; margin-right: 8px; }
  .history-list { max-height: 200px; overflow-y: auto; margin-top: 12px; }
  .history-item { padding: 8px; border-bottom: 1px solid var(--border); font-size: 13px; }
  #qrCode { margin-top: 12px; text-align: center; }
  @media (max-width: 768px) { .mn-grid { grid-template-columns: repeat(2,1fr); } .row { flex-direction: column; gap: 8px; } }
</style>
</head>
<body>
  <div class="wrap">
    <h1>Infinity ♾️ Wallet — Phantom Style</h1>
    <div class="card" id="authCard">
      <div class="small" id="statusLine">Status: Not signed in</div>
      <div style="margin-top:12px;" id="authForm">
        <input id="email" placeholder="Email (Gmail recommended)" />
        <input id="password" type="password" placeholder="Password (min 6 chars)" style="margin-top:10px" />
        <div class="row" style="margin-top:12px">
          <button id="btnSignIn">Sign in</button>
          <button class="ghost" id="btnSignUp">Create account</button>
          <button class="ghost hidden" id="btnSignOut">Sign out</button>
        </div>
        <div class="small muted" style="margin-top:10px" id="authHelp">Make sure domain added in Firebase → Auth → Authorized domains</div>
      </div>
    </div>

    <div id="app" class="hidden">
      <div class="row">
        <div class="card" style="flex:1;min-width:280px">
          <h3 style="margin-top:0;color:var(--accent)">Wallet Controls</h3>
          <div class="small">Create or import non-custodial wallet. Recovery phrase shown once securely.</div>
          <div class="row" style="margin-top:12px">
            <button id="btnCreate">Create New</button>
            <button class="ghost" id="btnImport">Import</button>
            <button class="ghost hidden" id="btnUnlock">Unlock Local</button>
          </div>
          <div class="small danger" style="margin-top:10px">Never share phrase. It stays on your device.</div>
        </div>

        <div class="card" style="flex:1;min-width:280px">
          <h3 style="margin-top:0;color:var(--accent)">Dashboard</h3>
          <div class="small">Signed in as: <span id="userInfo">-</span></div>
          <div style="margin-top:10px" class="small">Chain: 
            <select id="chainSel">
              <option value="eth">Ethereum</option>
              <option value="sol">Solana</option>
            </select>
          </div>
          <div style="margin-top:10px" class="small">Network: 
            <select id="network" style="margin-left:8px">
              <option value="sepolia">Sepolia (ETH Test)</option>
              <option value="homestead">Mainnet (ETH)</option>
              <option value="devnet">Devnet (SOL Test)</option>
              <option value="mainnet-beta">Mainnet (SOL)</option>
            </select>
          </div>
          <div style="margin-top:10px" class="small row">
            <img src="https://cryptofonts.com/img/icons/eth.svg" class="icon hidden" id="ethIcon" alt="ETH">
            <img src="https://cryptofonts.com/img/icons/sol.svg" class="icon hidden" id="solIcon" alt="SOL">
            Balance: <span id="balance">-</span> <span id="priceUsd" class="muted">(~$-- USD)</span>
          </div>
          <div style="margin-top:12px" class="row">
            <button class="ghost" id="btnRefresh">Refresh</button>
            <button class="ghost" id="btnExport">Export Phrase</button>
            <button class="ghost danger" id="btnDeleteLocal">Delete Local</button>
          </div>
        </div>
      </div>

      <div class="card" style="margin-top:16px">
        <h3 style="margin-top:0;color:var(--accent)">Assets</h3>
        <input id="coinSearch" placeholder="Search coins (e.g., ETH, SOL, USDC)" style="margin-bottom:10px" />
        <div id="coinList" class="small"></div>
      </div>

      <div class="row">
        <div class="card" style="flex:1">
          <h3 style="margin-top:0;color:var(--accent)">Deposit</h3>
          <div class="small">Address: <span id="address" style="word-break:break-all">-</span></div>
          <div id="qrCode"></div>
          <button id="btnCopyAddr" class="ghost" style="margin-top:10px">Copy Address</button>
        </div>

        <div class="card" style="flex:1">
          <h3 style="margin-top:0;color:var(--accent)">Send</h3>
          <input id="to" placeholder="Recipient address" style="margin-bottom:10px" />
          <input id="amt" type="number" step="0.000000001" placeholder="Amount" style="margin-bottom:10px" />
          <div class="row">
            <button id="btnSend">Send</button>
            <div id="txStatus" class="small"></div>
          </div>
        </div>
      </div>

      <div class="card" style="margin-top:16px">
        <h3 style="margin-top:0;color:var(--accent)">Transaction History</h3>
        <div id="history" class="history-list"></div>
      </div>

      <div class="small" style="margin-top:10px">Local Storage: <span id="storeStatus">none</span></div>
      <div class="small" style="margin-top:4px">Explorer: <a id="explorer" target="_blank" style="color:var(--accent)">Open</a></div>
    </div>

  </div>

  <!-- Mnemonic Modal -->
  <div id="mnModal" class="modal hidden">
    <div class="modal-card">
      <h3 style="color:var(--accent)">Your Recovery Phrase</h3>
      <div class="small danger">WARNING: Shown ONLY ONCE. Write down offline. Do not share or screenshot. Losing this loses your wallet.</div>
      <div id="mnGrid" class="mn-grid"></div>
      <div style="margin-top:12px" class="row">
        <button id="copyPhrase">Copy</button>
        <button class="ghost" id="downloadPhrase">Download TXT</button>
      </div>
      <div style="margin-top:12px">
        <input id="confirmSaved" placeholder='Type "I HAVE SAVED IT SECURELY" to continue' />
      </div>
      <div style="margin-top:12px" class="row">
        <button id="confirmSaveBtn">Confirm</button>
      </div>
      <div style="margin-top:12px" class="small muted">Then encrypt locally or skip.</div>
      <div style="margin-top:12px" id="mnActions" class="row hidden">
        <input id="savePwd" type="password" placeholder="Encryption password (min 8 chars)" />
        <button id="saveLocalBtn">Save Locally</button>
        <button class="ghost" id="skipSaveBtn">Skip</button>
      </div>
      <div style="margin-top:12px;text-align:right"><button class="ghost" id="closeMn">Close</button></div>
    </div>
  </div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";
import { getFirestore, doc, setDoc, getDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

// Firebase Config (Replace with yours)
const firebaseConfig = {
  apiKey: "AIzaSyBtbgeSVEwHGs50sHRe9GBle4xonalhIL0",
  authDomain: "anontalk-pfvvb.firebaseapp.com",
  projectId: "anontalk-pfvvb",
  storageBucket: "anontalk-pfvvb.firebasestorage.app",
  messagingSenderId: "600500129969",
  appId: "1:600500129969:web:f19c1c0b3603a44a00d290"
};

// RPCs
const RPC_URLS = {
  eth: {
    sepolia: "https://rpc.ankr.com/eth_sepolia",
    homestead: "https://rpc.ankr.com/eth"
  },
  sol: {
    devnet: "https://api.devnet.solana.com",
    'mainnet-beta': "https://api.mainnet-beta.solana.com"
  }
};

// CoinGecko IDs
const COIN_IDS = { eth: 'ethereum', sol: 'solana' };

// Popular coins for search
const POPULAR_COINS = ['ETH', 'SOL', 'USDC', 'BTC', 'BNB'];

// INIT
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);

// UI Refs
const statusLine = document.getElementById('statusLine');
const emailEl = document.getElementById('email'), pwdEl = document.getElementById('password');
const btnSignIn = document.getElementById('btnSignIn'), btnSignUp = document.getElementById('btnSignUp'), btnSignOut = document.getElementById('btnSignOut');
const appDiv = document.getElementById('app'), userInfo = document.getElementById('userInfo');
const btnCreate = document.getElementById('btnCreate'), btnImport = document.getElementById('btnImport'), btnUnlock = document.getElementById('btnUnlock');
const addressEl = document.getElementById('address'), balanceEl = document.getElementById('balance'), priceUsd = document.getElementById('priceUsd');
const chainSel = document.getElementById('chainSel'), network = document.getElementById('network');
const btnRefresh = document.getElementById('btnRefresh'), btnExport = document.getElementById('btnExport'), btnDeleteLocal = document.getElementById('btnDeleteLocal');
const toInput = document.getElementById('to'), amtInput = document.getElementById('amt');
const btnSend = document.getElementById('btnSend'), txStatus = document.getElementById('txStatus'), explorer = document.getElementById('explorer');
const mnModal = document.getElementById('mnModal'), mnGrid = document.getElementById('mnGrid'), confirmSaved = document.getElementById('confirmSaved');
const confirmSaveBtn = document.getElementById('confirmSaveBtn'), mnActions = document.getElementById('mnActions');
const savePwd = document.getElementById('savePwd'), saveLocalBtn = document.getElementById('saveLocalBtn'), skipSaveBtn = document.getElementById('skipSaveBtn');
const copyPhraseBtn = document.getElementById('copyPhrase'), downloadPhraseBtn = document.getElementById('downloadPhrase'), closeMn = document.getElementById('closeMn');
const storeStatusEl = document.getElementById('storeStatus');
const historyEl = document.getElementById('history');
const qrCodeEl = document.getElementById('qrCode');
const btnCopyAddr = document.getElementById('btnCopyAddr');
const coinSearch = document.getElementById('coinSearch'), coinList = document.getElementById('coinList');
const ethIcon = document.getElementById('ethIcon'), solIcon = document.getElementById('solIcon');

let state = { user: null, chain: 'eth', network: 'sepolia', provider: null, wallet: null, address: null, mnemonic: null, price: 0 };

// Crypto Helpers
const bytesToHex = (bytes) => Array.from(new Uint8Array(bytes)).map(b => b.toString(16).padStart(2, '0')).join('');
const hexToBytes = (hex) => { const out = new Uint8Array(hex.length / 2); for (let i = 0; i < out.length; i++) out[i] = parseInt(hex.substr(i * 2, 2), 16); return out; };
async function deriveKey(password, saltHex) {
  const enc = new TextEncoder();
  const passKey = await crypto.subtle.importKey('raw', enc.encode(password), { name: 'PBKDF2' }, false, ['deriveKey']);
  const key = await crypto.subtle.deriveKey({ name: 'PBKDF2', salt: hexToBytes(saltHex), iterations: 250000, hash: 'SHA-512' }, passKey, { name: 'AES-GCM', length: 256 }, false, ['encrypt', 'decrypt']);
  return key;
}
async function encryptText(password, plaintext) {
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const key = await deriveKey(password, bytesToHex(salt));
  const ct = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, new TextEncoder().encode(plaintext));
  return { salt: bytesToHex(salt), iv: bytesToHex(iv), cipher: bytesToHex(ct) };
}
async function decryptText(password, obj) {
  const key = await deriveKey(password, obj.salt);
  const pt = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: hexToBytes(obj.iv) }, key, hexToBytes(obj.cipher));
  return new TextDecoder().decode(pt);
}

// Local Storage
const LOCAL_KEY = 'infinity_wallet_v3';
function saveLocal(obj) { localStorage.setItem(LOCAL_KEY, JSON.stringify(obj)); }
function loadLocal() { const j = localStorage.getItem(LOCAL_KEY); return j ? JSON.parse(j) : null; }
function deleteLocal() { localStorage.removeItem(LOCAL_KEY); }

// Firestore
async function markUserAddress(uid, address) {
  if (!uid) return;
  try {
    const uref = doc(db, 'users', uid);
    await setDoc(uref, { hasWallet: true, address, chain: state.chain, updatedAt: serverTimestamp() }, { merge: true });
  } catch (e) { console.warn(e); }
}

// Auth
btnSignUp.addEventListener('click', async () => {
  const email = emailEl.value.trim(), pwd = pwdEl.value;
  if (!email || pwd.length < 6) return alert('Valid email and min 6 char password.');
  try {
    await createUserWithEmailAndPassword(auth, email, pwd);
    alert('Created.');
  } catch (e) { alert('Signup failed: ' + e.message); }
});

btnSignIn.addEventListener('click', async () => {
  const email = emailEl.value.trim(), pwd = pwdEl.value;
  if (!email || !pwd) return alert('Enter email/password.');
  try {
    await signInWithEmailAndPassword(auth, email, pwd);
  } catch (e) { alert('Signin failed: ' + e.message); }
});

btnSignOut.addEventListener('click', async () => { await signOut(auth); location.reload(); });

onAuthStateChanged(auth, async (user) => {
  state.user = user;
  if (user) {
    statusLine.textContent = 'Signed in as ' + (user.email || user.uid);
    document.getElementById('authForm').classList.add('hidden');
    btnSignOut.classList.remove('hidden');
    appDiv.classList.remove('hidden');
    userInfo.textContent = user.email || user.uid;
    const obj = loadLocal();
    storeStatusEl.textContent = obj ? 'Encrypted' : 'None';
    storeStatusEl.className = obj ? 'success' : 'danger';
    if (obj) btnUnlock.classList.remove('hidden');
    initChain();
  } else {
    statusLine.textContent = 'Not signed in';
    document.getElementById('authForm').classList.remove('hidden');
    btnSignOut.classList.add('hidden');
    appDiv.classList.add('hidden');
  }
});

// Show Mnemonic
function showMnemonicModal(phrase) {
  state.mnemonic = phrase;
  mnGrid.innerHTML = '';
  const words = phrase.split(' ');
  words.forEach((w, i) => {
    const cell = document.createElement('div');
    cell.className = 'mn-cell';
    cell.innerHTML = `<div class="small muted">#\( {i + 1}</div><div> \){w}</div>`;
    mnGrid.appendChild(cell);
  });
  confirmSaved.value = '';
  mnActions.classList.add('hidden');
  mnModal.classList.remove('hidden');
}

// Mnemonic Actions
copyPhraseBtn.onclick = async () => {
  try {
    await navigator.clipboard.writeText(state.mnemonic);
    alert('Copied.');
  } catch (e) { alert('Copy failed.'); }
};
downloadPhraseBtn.onclick = () => {
  const blob = new Blob([state.mnemonic], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'recovery.txt';
  a.click();
  URL.revokeObjectURL(url);
};
confirmSaveBtn.onclick = () => {
  if (confirmSaved.value.trim() !== 'I HAVE SAVED IT SECURELY') return alert('Type exactly as shown.');
  mnActions.classList.remove('hidden');
};
saveLocalBtn.onclick = async () => {
  const pwd = savePwd.value;
  if (pwd.length < 8) return alert('Min 8 chars.');
  try {
    const enc = await encryptText(pwd, state.mnemonic);
    enc.chain = state.chain;
    enc.address = state.address;
    saveLocal(enc);
    storeStatusEl.textContent = 'Encrypted';
    storeStatusEl.className = 'success';
    mnModal.classList.add('hidden');
    if (state.user) markUserAddress(state.user.uid, state.address);
    alert('Saved locally.');
  } catch (e) { alert('Error: ' + e.message); }
};
skipSaveBtn.onclick = () => {
  mnModal.classList.add('hidden');
  alert('Not saved locally. Keep phrase safe.');
};
closeMn.onclick = () => mnModal.classList.add('hidden');

// Wallet Creation
btnCreate.addEventListener('click', async () => {
  let phrase, wallet;
  if (state.chain === 'eth') {
    wallet = ethers.Wallet.createRandom();
    phrase = wallet.mnemonic.phrase;
    state.wallet = wallet;
    state.address = wallet.address;
  } else {
    wallet = solanaWeb3.Keypair.generate();
    phrase = 'Solana uses keypair, not mnemonic. Private: ' + bytesToHex(wallet.secretKey); // For simplicity, use as phrase
    state.wallet = wallet;
    state.address = wallet.publicKey.toBase58();
  }
  showMnemonicModal(phrase);
  updateUI();
});
  btnImport.addEventListener('click', async () => {
  const phrase = prompt('Enter recovery phrase or private key:');
  if (!phrase) return;
  try {
    let wallet;
    if (state.chain === 'eth') {
      wallet = ethers.Wallet.fromMnemonic(phrase);
      state.address = wallet.address;
    } else {
      const key = hexToBytes(phrase); // Assume hex private
      wallet = solanaWeb3.Keypair.fromSecretKey(key);
      state.address = wallet.publicKey.toBase58();
    }
    state.wallet = wallet;
    state.mnemonic = phrase;
    updateUI();
    if (confirm('Save locally encrypted?')) {
      const pwd = prompt('Password (min 8):');
      if (pwd.length < 8) return alert('Canceled.');
      const enc = await encryptText(pwd, phrase);
      enc.chain = state.chain;
      enc.address = state.address;
      saveLocal(enc);
      storeStatusEl.textContent = 'Encrypted';
      storeStatusEl.className = 'success';
      alert('Imported and saved.');
    } else {
      alert('Imported.');
    }
  } catch (e) { alert('Import failed: ' + e.message); }
});

btnUnlock.addEventListener('click', async () => {
  const obj = loadLocal();
  if (!obj) return alert('No local.');
  const pwd = prompt('Password:');
  if (!pwd) return;
  try {
    const phrase = await decryptText(pwd, obj);
    state.chain = obj.chain || 'eth';
    chainSel.value = state.chain;
    if (state.chain === 'eth') {
      state.wallet = ethers.Wallet.fromMnemonic(phrase);
      state.address = state.wallet.address;
    } else {
      const key = hexToBytes(phrase);
      state.wallet = solanaWeb3.Keypair.fromSecretKey(key);
      state.address = state.wallet.publicKey.toBase58();
    }
    state.mnemonic = phrase;
    updateUI();
    alert('Unlocked. Phrase shown.');
    showMnemonicModal(phrase);
  } catch (e) { alert('Failed: ' + e.message); }
});

btnExport.addEventListener('click', async () => {
  const obj = loadLocal();
  if (!obj) return alert('No local.');
  const pwd = prompt('Password:');
  if (!pwd) return;
  try {
    const phrase = await decryptText(pwd, obj);
    showMnemonicModal(phrase);
  } catch (e) { alert('Failed: ' + e.message); }
});

btnDeleteLocal.addEventListener('click', () => {
  if (confirm('Delete local?')) {
    deleteLocal();
    storeStatusEl.textContent = 'None';
    storeStatusEl.className = 'danger';
    state.wallet = null;
    state.address = null;
    updateUI();
    alert('Deleted.');
  }
});

// Chain/Network Change
chainSel.addEventListener('change', () => {
  state.chain = chainSel.value;
  initChain();
  updateUI();
});
network.addEventListener('change', () => {
  state.network = network.value;
  initChain();
  updateUI();
});

// Init Chain
function initChain() {
  const rpc = RPC_URLS[state.chain][state.network];
  if (state.chain === 'eth') {
    state.provider = new ethers.providers.JsonRpcProvider(rpc);
  } else {
    state.provider = new solanaWeb3.Connection(rpc);
  }
}

// Update UI
function updateUI() {
  addressEl.textContent = state.address || '-';
  ethIcon.classList.toggle('hidden', state.chain !== 'eth');
  solIcon.classList.toggle('hidden', state.chain !== 'sol');
  if (state.address) {
    QRCode.toCanvas(qrCodeEl, state.address, { width: 128 }, (err) => { if (err) console.error(err); });
  } else {
    qrCodeEl.innerHTML = '';
  }
  updateExplorer();
  refreshBalance();
  refreshHistory();
}

// Copy Address
btnCopyAddr.addEventListener('click', async () => {
  if (!state.address) return alert('No address.');
  try {
    await navigator.clipboard.writeText(state.address);
    alert('Copied.');
  } catch (e) { alert('Copy failed.'); }
});

// Refresh
btnRefresh.addEventListener('click', refreshBalance);
async function refreshBalance() {
  if (!state.address) return;
  balanceEl.innerHTML = '<div class="loader"></div>';
  try {
    let bal;
    if (state.chain === 'eth') {
      bal = await state.provider.getBalance(state.address);
      balanceEl.textContent = ethers.utils.formatEther(bal);
    } else {
      bal = await state.provider.getBalance(new solanaWeb3.PublicKey(state.address));
      balanceEl.textContent = bal / solanaWeb3.LAMPORTS_PER_SOL;
    }
    refreshPrice();
  } catch (e) { balanceEl.textContent = 'Error'; }
}

async function refreshPrice() {
  try {
    const res = await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${COIN_IDS[state.chain]}&vs_currencies=usd`);
    const data = await res.json();
    state.price = data[COIN_IDS[state.chain]].usd;
    priceUsd.textContent = `(~$${state.price} USD)`;
  } catch (e) { priceUsd.textContent = '(Price error)'; }
}
setInterval(refreshPrice, 30000); // Every 30s

// Send
btnSend.addEventListener('click', async () => {
  const to = toInput.value.trim(), amt = parseFloat(amtInput.value);
  if (!to || amt <= 0) return alert('Invalid to/amount.');
  const obj = loadLocal();
  if (!obj) return alert('No wallet.');
  const pwd = prompt('Password to sign:');
  if (!pwd) return;
  try {
    const phrase = await decryptText(pwd, obj);
    let signer;
    if (state.chain === 'eth') {
      signer = ethers.Wallet.fromMnemonic(phrase).connect(state.provider);
      const tx = await signer.sendTransaction({ to, value: ethers.utils.parseEther(amt.toString()) });
      txStatus.textContent = 'Sent: ' + tx.hash;
    } else {
      const fromKey = solanaWeb3.Keypair.fromSecretKey(hexToBytes(phrase));
      const toPub = new solanaWeb3.PublicKey(to);
      const tx = new solanaWeb3.Transaction().add(
        solanaWeb3.SystemProgram.transfer({
          fromPubkey: fromKey.publicKey,
          toPubkey: toPub,
          lamports: amt * solanaWeb3.LAMPORTS_PER_SOL,
        })
      );
      const sig = await solanaWeb3.sendAndConfirmTransaction(state.provider, tx, [fromKey]);
      txStatus.textContent = 'Sent: ' + sig;
    }
    setTimeout(refreshBalance, 5000);
    refreshHistory();
  } catch (e) { txStatus.textContent = 'Error: ' + e.message; }
});

// History
async function refreshHistory() {
  historyEl.innerHTML = '<div class="loader"></div>';
  try {
    let hist = [];
    if (state.chain === 'eth') {
      const count = await state.provider.getTransactionCount(state.address);
      for (let i = count - 1; i >= Math.max(0, count - 10); i--) {
        const block = await state.provider.getBlockWithTransactions(await state.provider.getBlockNumber());
        const txs = block.transactions.filter(tx => tx.from === state.address || tx.to === state.address);
        hist.push(...txs.map(tx => ({ hash: tx.hash, amt: ethers.utils.formatEther(tx.value), from: tx.from })));
      }
    } else {
      const pub = new solanaWeb3.PublicKey(state.address);
      const sigs = await state.provider.getSignaturesForAddress(pub, { limit: 10 });
      hist = await state.provider.getParsedTransactions(sigs.map(s => s.signature));
      hist = hist.map(tx => ({ hash: tx.transaction.signatures[0], amt: tx.transaction.message.instructions[0].parsed.info.lamports / solanaWeb3.LAMPORTS_PER_SOL, from: tx.transaction.message.accountKeys[0].pubkey.toBase58() }));
    }
    historyEl.innerHTML = hist.map(h => `<div class="history-item">TX: ${h.hash.slice(0,10)}... Amt: ${h.amt} From: ${h.from.slice(0,10)}...</div>`).join('');
  } catch (e) { historyEl.innerHTML = '<div class="small danger">History error</div>'; }
}

// Explorer
function updateExplorer() {
  let base;
  if (state.chain === 'eth') {
    base = state.network === 'homestead' ? 'https://etherscan.io/address/' : 'https://sepolia.etherscan.io/address/';
  } else {
    base = state.network === 'mainnet-beta' ? 'https://solscan.io/account/' : 'https://solscan.io/account/?cluster=devnet';
  }
  explorer.href = base + (state.address || '');
}

// Coin Search
coinSearch.addEventListener('input', () => {
  const q = coinSearch.value.toUpperCase();
  const filtered = POPULAR_COINS.filter(c => c.includes(q));
  coinList.innerHTML = filtered.map(c => `<div class="small row"><img src="https://cryptofonts.com/img/icons/\( {c.toLowerCase()}.svg" class="icon" alt=" \){c}"> ${c}</div>`).join('');
});

// Load
window.addEventListener('load', () => {
  const obj = loadLocal();
  storeStatusEl.textContent = obj ? 'Encrypted' : 'None';
  storeStatusEl.className = obj ? 'success' : 'danger';
  if (obj) btnUnlock.classList.remove('hidden');
  initChain();
  coinList.innerHTML = POPULAR_COINS.map(c => `<div class="small row"><img src="https://cryptofonts.com/img/icons/\( {c.toLowerCase()}.svg" class="icon" alt=" \){c}"> ${c}</div>`).join('');
});
</script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Infinity ♾️ Wallet — Improved</title>
<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>

<style>
  :root{--bg:#000;--card:#0c0c0c;--muted:#9fb3c8;--accent:#fff;--danger:#ff6b6b}
  body{margin:0;background:var(--bg);color:#fff;font-family:Inter,Arial;padding:18px}
  .wrap{max-width:980px;margin:0 auto}
  .card{background:var(--card);padding:14px;border-radius:10px;margin-bottom:12px;border:1px solid rgba(255,255,255,0.03)}
  h1{margin:0 0 8px;font-size:20px}
  input,select,textarea{width:100%;padding:10px;border-radius:8px;background:#060707;border:1px solid rgba(255,255,255,0.03);color:#fff}
  button{padding:10px 12px;border-radius:8px;border:none;cursor:pointer;background:var(--accent);color:#000;font-weight:700}
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
  .row{display:flex;gap:8px;align-items:center}
  .small{color:var(--muted);font-size:13px}
  .danger{color:var(--danger)}
  .hidden{display:none}
  .mn-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:8px}
  .mn-cell{background:#050606;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);font-weight:600}
  .modal{position:fixed;inset:0;background:rgba(0,0,0,0.7);display:flex;align-items:center;justify-content:center;padding:12px}
  .modal-card{background:#071217;padding:16px;border-radius:12px;max-width:720px;width:100%}
  .muted{color:var(--muted)}
  pre{background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;color:#cfefff;overflow:auto}
  @media(max-width:720px){ .mn-grid{grid-template-columns:repeat(2,1fr)} .row{flex-direction:column} }
</style>
</head>
<body>
  <div class="wrap">
    <h1>Infinity ♾️ Wallet — Improved</h1>
    <div class="card" id="authCard">
      <div class="small" id="statusLine">Status: Not signed in</div>
      <div style="margin-top:10px;" id="authForm">
        <input id="email" placeholder="Email (Gmail recommended)" />
        <input id="password" type="password" placeholder="Password (min 6 chars)" style="margin-top:8px" />
        <div class="row" style="margin-top:10px">
          <button id="btnSignIn">Sign in</button>
          <button class="ghost" id="btnSignUp">Create account</button>
          <button class="ghost hidden" id="btnSignOut">Sign out</button>
        </div>
        <div class="small muted" style="margin-top:8px" id="authHelp">Make sure domain added in Firebase → Auth → Authorized domains</div>
      </div>
    </div>

    <div id="app" class="hidden">
      <div class="row">
        <div class="card" style="flex:1;min-width:260px">
          <h3 style="margin-top:0">Wallet Controls</h3>
          <div class="small">Create/import non-custodial wallet (BIP-39). Phrase shown once in numbered view. Optionally save encrypted locally.</div>
          <div class="row" style="margin-top:10px">
            <button id="btnCreate">Create New Wallet</button>
            <button class="ghost" id="btnImport">Import Wallet</button>
            <button class="ghost hidden" id="btnUnlock">Unlock Local</button>
          </div>
          <div class="small danger" style="margin-top:8px">Never share phrase. We never send it to server.</div>
        </div>

        <div class="card" style="width:380px;min-width:260px">
          <h3 style="margin-top:0">Dashboard</h3>
          <div class="small">Signed in: <div id="userInfo" style="font-weight:700;margin-top:6px">-</div></div>
          <div style="margin-top:8px" class="small">Address</div>
          <div id="address" style="font-weight:700;margin-top:6px">-</div>
          <div style="margin-top:8px" class="small">Network
            <select id="network" style="margin-left:6px">
              <option value="goerli">Goerli (test)</option>
              <option value="sepolia">Sepolia (test)</option>
              <option value="homestead">Mainnet</option>
            </select>
          </div>
          <div style="margin-top:8px" class="small">Balance: <span id="balance">-</span></div>
          <div style="margin-top:8px" class="row">
            <button class="ghost" id="btnRefresh">Refresh</button>
            <button class="ghost" id="btnExport">Export Phrase</button>
            <button class="ghost danger" id="btnDeleteLocal">Delete Local</button>
          </div>
        </div>
      </div>

      <div id="sendCard" class="card hidden" style="margin-top:12px">
        <h3 style="margin-top:0">Send ETH</h3>
        <div class="row" style="margin-bottom:8px">
          <input id="to" placeholder="Recipient address" />
          <input id="amt" placeholder="Amount (ETH)" style="width:140px" />
        </div>
        <div class="row"><button id="btnSend">Send (decrypt & sign)</button><div id="txStatus" class="small" style="margin-left:8px"></div></div>
        <div style="margin-top:8px" class="small">Explorer: <a id="explorer" target="_blank">Open address</a></div>
        <div style="margin-top:6px" class="small">Storage: <span id="storeStatus">none</span></div>
      </div>
    </div>

  </div>

  <!-- Modal for mnemonic display -->
  <div id="mnModal" class="modal hidden">
    <div class="modal-card">
      <h3>Save your recovery phrase</h3>
      <div class="small danger">This phrase is shown ONLY ONCE. Copy and store offline. Do not share.</div>
      <div id="mnGrid" class="mn-grid"></div>
      <div style="margin-top:10px" class="row">
        <button id="copyPhrase">Copy phrase</button>
        <button class="ghost" id="downloadPhrase">Download (text)</button>
        <div class="right">
          <input id="confirmSaved" placeholder='Type "I SAVED" to confirm' />
          <button class="ghost" id="confirmSaveBtn">Confirm</button>
        </div>
      </div>
      <div style="margin-top:8px" class="small">After confirming you can encrypt & save local copy or skip saving locally.</div>
      <div style="margin-top:8px" id="mnActions" class="row hidden">
        <input id="savePwd" placeholder="Local encryption password (min 6 chars)" type="password" />
        <button id="saveLocalBtn">Encrypt & Save Locally</button>
        <button class="ghost" id="skipSaveBtn">Skip Saving</button>
      </div>
      <div style="margin-top:8px;text-align:right"><button id="closeMn" class="ghost">Close</button></div>
    </div>
  </div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";
import { getFirestore, doc, setDoc, getDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";
  /* ----- CONFIG ----- (your firebase config) */
const firebaseConfig = {
  apiKey: "AIzaSyBtbgeSVEwHGs50sHRe9GBle4xonalhIL0",
  authDomain: "anontalk-pfvvb.firebaseapp.com",
  projectId: "anontalk-pfvvb",
  storageBucket: "anontalk-pfvvb.firebasestorage.app",
  messagingSenderId: "600500129969",
  appId: "1:600500129969:web:f19c1c0b3603a44a00d290"
};
/* RPCs (replace mainnet before real funds) */
const RPC_URLS = { goerli:"https://rpc.ankr.com/eth_goerli", sepolia:"https://rpc.ankr.com/eth_sepolia", homestead:"https://mainnet.infura.io/v3/YOUR_INFURA_KEY" };

/* ----- INIT ----- */
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);

/* UI refs */
const statusLine = document.getElementById('statusLine');
const emailEl = document.getElementById('email'), pwdEl = document.getElementById('password');
const btnSignIn = document.getElementById('btnSignIn'), btnSignUp = document.getElementById('btnSignUp'), btnSignOut = document.getElementById('btnSignOut');
const appDiv = document.getElementById('app'), userInfo = document.getElementById('userInfo');
const btnCreate = document.getElementById('btnCreate'), btnImport = document.getElementById('btnImport'), btnUnlock = document.getElementById('btnUnlock');
const addressEl = document.getElementById('address'), balanceEl = document.getElementById('balance'), storeStatusEl = document.getElementById('storeStatus');
const networkSel = document.getElementById('network'), btnRefresh = document.getElementById('btnRefresh');
const btnExport = document.getElementById('btnExport'), btnDeleteLocal = document.getElementById('btnDeleteLocal');
const sendCard = document.getElementById('sendCard'), toInput = document.getElementById('to'), amtInput = document.getElementById('amt');
const btnSend = document.getElementById('btnSend'), txStatus = document.getElementById('txStatus'), explorer = document.getElementById('explorer');

const mnModal = document.getElementById('mnModal'), mnGrid = document.getElementById('mnGrid'), confirmSaved = document.getElementById('confirmSaved');
const confirmSaveBtn = document.getElementById('confirmSaveBtn'), mnActions = document.getElementById('mnActions');
const savePwd = document.getElementById('savePwd'), saveLocalBtn = document.getElementById('saveLocalBtn'), skipSaveBtn = document.getElementById('skipSaveBtn');
const copyPhraseBtn = document.getElementById('copyPhrase'), downloadPhraseBtn = document.getElementById('downloadPhrase'), closeMn = document.getElementById('closeMn');

let state = { user:null, provider:null, walletAddress:null, network:networkSel.value, currentMnemonic:null };

/* ----- WEB CRYPTO helpers (PBKDF2 + AES-GCM) ----- */
const bytesToHex = (bytes) => Array.from(new Uint8Array(bytes)).map(b=>b.toString(16).padStart(2,'0')).join('');
const hexToBytes = (hex)=>{ if(!hex) return new Uint8Array(); const out=new Uint8Array(hex.length/2); for(let i=0;i<out.length;i++) out[i]=parseInt(hex.substr(i*2,2),16); return out; };
async function deriveKey(password, saltHex){ const enc=new TextEncoder(); const passKey = await crypto.subtle.importKey('raw', enc.encode(password), {name:'PBKDF2'}, false, ['deriveKey']); const key = await crypto.subtle.deriveKey({name:'PBKDF2', salt:hexToBytes(saltHex), iterations:150000, hash:'SHA-256'}, passKey, {name:'AES-GCM', length:256}, false, ['encrypt','decrypt']); return key; }
async function encryptText(password, plaintext){ const salt = crypto.getRandomValues(new Uint8Array(16)); const iv = crypto.getRandomValues(new Uint8Array(12)); const key = await deriveKey(password, bytesToHex(salt)); const ct = await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, new TextEncoder().encode(plaintext)); return {salt:bytesToHex(salt), iv:bytesToHex(iv), cipher:bytesToHex(ct)}; }
async function decryptText(password, obj){ const key = await deriveKey(password, obj.salt); const pt = await crypto.subtle.decrypt({name:'AES-GCM', iv:hexToBytes(obj.iv)}, key, hexToBytes(obj.cipher)); return new TextDecoder().decode(pt); }

/* ----- local storage ----- */
const LOCAL_KEY = 'infinity_wallet_v1';
function saveLocal(obj){ localStorage.setItem(LOCAL_KEY, JSON.stringify(obj)); }
function loadLocal(){ const j=localStorage.getItem(LOCAL_KEY); return j?JSON.parse(j):null; }
function deleteLocal(){ localStorage.removeItem(LOCAL_KEY); }

/* ----- Firestore safe write (address only) ----- */
async function markUserAddress(uid, address){ if(!uid) return; try{ const uref = doc(db,'users',uid); await setDoc(uref, {hasWallet:true, address, updatedAt:serverTimestamp()}, {merge:true}); } catch(e){console.warn(e);} }

/* ----- Auth handlers with better errors ----- */
btnSignUp.addEventListener('click', async ()=>{
  const email = emailEl.value.trim(), pwd = pwdEl.value;
  if(!email||!pwd) return alert('Enter email & password (min 6 chars).');
  try{
    await createUserWithEmailAndPassword(auth, email, pwd);
    alert('Account created and signed in.');
  } catch(e){
    // helpful messages
    if(e.code === 'auth/email-already-in-use') {
      if(confirm('Email already in use. Do you want to try sign-in instead?')) {
        try { await signInWithEmailAndPassword(auth,email,pwd); } catch(err){ alert('Sign-in failed: ' + err.message); }
      }
    } else if(e.code === 'auth/weak-password') alert('Password too weak. Use 6+ characters.');
    else alert('Signup failed: ' + e.message);
  }
});

btnSignIn.addEventListener('click', async ()=>{
  const email = emailEl.value.trim(), pwd = pwdEl.value;
  if(!email||!pwd) return alert('Enter email & password.');
  try{
    await signInWithEmailAndPassword(auth, email, pwd);
  } catch(e){
    if(e.code === 'auth/wrong-password') alert('Wrong password. Try again.');
    else if(e.code === 'auth/user-not-found') alert('No account found. Create an account first.');
    else alert('Sign-in failed: ' + e.message);
  }
});

btnSignOut.addEventListener('click', async ()=> { await signOut(auth); location.reload(); });

onAuthStateChanged(auth, async (user)=>{
  state.user = user;
  if(user){
    statusLine.textContent = 'Status: Signed in as ' + (user.email || user.uid);
    document.getElementById('authForm').classList.add('hidden');
    btnSignOut.classList.remove('hidden');
    appDiv.classList.remove('hidden');
    userInfo.textContent = user.email || user.uid;
    const obj = loadLocal(); storeStatusEl.textContent = obj ? 'encrypted (local)' : 'none';
    if(obj) document.getElementById('btnUnlock').classList.remove('hidden');
    // write safe profile
    try{ const uref = doc(db,'users',user.uid); const existing = await getDoc(uref); await setDoc(uref, { uid:user.uid, email:user.email||null, createdAt: existing && existing.exists() ? existing.data().createdAt || serverTimestamp() : serverTimestamp(), updatedAt: serverTimestamp()}, {merge:true}); } catch(e){ console.warn(e); }
  } else {
    statusLine.textContent = 'Status: Not signed in';
    document.getElementById('authForm').classList.remove('hidden');
    btnSignOut.classList.add('hidden');
    appDiv.classList.add('hidden');
  }
});

/* ----- Wallet flows ----- */

/* show mnemonic modal in numbered grid */
function showMnemonicModal(phrase){
  state.currentMnemonic = phrase;
  mnGrid.innerHTML = '';
  const words = phrase.trim().split(/\s+/);
  words.forEach((w,i)=>{
    const cell = document.createElement('div');
    cell.className = 'mn-cell';
    cell.innerHTML = `<div style="font-size:12px;color:var(--muted)">#${i+1}</div><div style="margin-top:6px">${w}</div>`;
    mnGrid.appendChild(cell);
  });
  confirmSaved.value = '';
  mnActions.classList.add('hidden');
  mnModal.classList.remove('hidden');
}

/* copy / download */
copyPhraseBtn.onclick = async ()=>{
  if(!state.currentMnemonic) return;
  try { await navigator.clipboard.writeText(state.currentMnemonic); alert('Copied to clipboard'); } catch(e){ alert('Copy failed'); }
};
downloadPhraseBtn.onclick = ()=>{
  if(!state.currentMnemonic) return;
  const blob = new Blob([state.currentMnemonic], {type:'text/plain'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'infinity-recovery-phrase.txt'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
};

/* confirm button -> show local save options */
confirmSaveBtn.onclick = ()=>{
  if(confirmSaved.value.trim() !== 'I SAVED') return alert('Type exactly: I SAVED');
  mnActions.classList.remove('hidden');
};

/* save local encrypted */
saveLocalBtn.onclick = async ()=>{
  const pwd = savePwd.value;
  if(!pwd || pwd.length < 6) return alert('Password min 6 chars');
  try {
    const enc = await encryptText(pwd, state.currentMnemonic);
    enc.address = state.walletAddress || null;
    saveLocal(enc);
    storeStatusEl.textContent = 'encrypted (local)';
    mnModal.classList.add('hidden');
    alert('Encrypted mnemonic saved locally.');
    if(state.user && state.walletAddress) markUserAddress(state.user.uid, state.walletAddress);
  } catch(e){ alert('Encryption failed: ' + e.message); }
};

/* skip saving locally */
skipSaveBtn.onclick = ()=>{ mnModal.classList.add('hidden'); alert('Wallet created (not saved locally). Keep phrase safe.'); };

/* close modal */
closeMn.onclick = ()=> mnModal.classList.add('hidden');

/* create wallet */
document.getElementById('btnCreate').addEventListener('click', async ()=>{
  const wallet = ethers.Wallet.createRandom();
  const phrase = wallet.mnemonic.phrase;
  state.walletAddress = wallet.address;
  // show phrase UI (numbered)
  showMnemonicModal(phrase);
  // update UI address (but don't auto-save)
  addressEl.textContent = wallet.address;
  sendCard.classList.remove('hidden');
  explorer.href = '#';
});

/* import wallet */
document.getElementById('btnImport').addEventListener('click', async ()=>{
  const phrase = prompt('Paste 12-word phrase:');
  if(!phrase) return;
  try {
    const w = ethers.Wallet.fromMnemonic(phrase);
    state.walletAddress = w.address;
    addressEl.textContent = w.address;
    sendCard.classList.remove('hidden');
    // ask if want to save locally
    if(confirm('Do you want to save an encrypted local copy?')) {
      const pwd = prompt('Set a local encryption password (min 6 chars):');
      if(!pwd || pwd.length<6) return alert('Password too weak or canceled');
      const enc = await encryptText(pwd, phrase);
      enc.address = w.address;
      saveLocal(enc);
      storeStatusEl.textContent = 'encrypted (local)';
      if(state.user) markUserAddress(state.user.uid, w.address);
      alert('Imported & encrypted locally.');
    } else {
      alert('Imported wallet (not saved locally).');
    }
  } catch(e){ alert('Import failed: invalid phrase or error: ' + e.message); }
});

/* unlock local */
document.getElementById('btnUnlock').addEventListener('click', async ()=>{
  const obj = loadLocal();
  if(!obj) return alert('No local wallet saved');
  const pwd = prompt('Enter local encryption password:'); if(!pwd) return;
  try {
    const phrase = await decryptText(pwd, obj);
    const w = ethers.Wallet.fromMnemonic(phrase);
    state.walletAddress = w.address;
    addressEl.textContent = w.address;
    sendCard.classList.remove('hidden');
    alert('Unlocked. Phrase will be shown now — copy & store offline.');
    showMnemonicModal(phrase);
  } catch(e){ alert('Decryption failed: ' + e.message); }
});
  /* export */
btnExport.addEventListener('click', async ()=>{
  const obj = loadLocal();
  if(!obj) return alert('No local wallet saved');
  const pwd = prompt('Enter password to export phrase:'); if(!pwd) return;
  try {
    const phrase = await decryptText(pwd, obj);
    showMnemonicModal(phrase);
  } catch(e){ alert('Wrong password'); }
});

/* delete local */
btnDeleteLocal.addEventListener('click', ()=>{
  if(confirm('Delete local encrypted wallet?')){ deleteLocal(); storeStatusEl.textContent='none'; walletClear(); alert('Deleted local copy'); }
});

/* send tx */
btnSend.addEventListener('click', async ()=>{
  const to = toInput.value.trim(), amt = amtInput.value.trim();
  if(!to||!amt) return alert('Fill recipient & amount');
  const obj = loadLocal(); if(!obj) return alert('No local wallet saved to sign. Import/create and save locally.');
  const pwd = prompt('Enter encryption password to sign tx:'); if(!pwd) return;
  try {
    const phrase = await decryptText(pwd, obj);
    const wallet = ethers.Wallet.fromMnemonic(phrase);
    configureProvider(networkSel.value);
    const signer = wallet.connect(state.provider);
    txStatus.textContent = 'Sending...';
    const tx = await signer.sendTransaction({ to, value: ethers.utils.parseEther(amt) });
    txStatus.textContent = 'Sent: ' + tx.hash;
    setTimeout(()=> refreshBalance(), 4000);
  } catch(e){ txStatus.textContent='Error'; alert('Send failed: ' + e.message); }
});

/* provider & balance */
networkSel.addEventListener('change', ()=>{ configureProvider(networkSel.value); refreshBalance(); updateExplorer(); });
function configureProvider(net){ state.network = net; const url = RPC_URLS[net]; try { state.provider = url ? new ethers.providers.JsonRpcProvider(url) : ethers.getDefaultProvider(net); } catch(e){ state.provider = ethers.getDefaultProvider(net); } }
async function refreshBalance(){ if(!state.walletAddress) return; try { const bal = await state.provider.getBalance(state.walletAddress); balanceEl.textContent = ethers.utils.formatEther(bal) + ' ETH'; } catch(e){ balanceEl.textContent='error'; } }
function updateExplorer(){ const net = state.network; const base = net==='homestead' ? 'https://etherscan.io/address/' : (net==='goerli' ? 'https://goerli.etherscan.io/address/' : 'https://sepolia.etherscan.io/address/'); explorer.href = base + (state.walletAddress || ''); }
document.getElementById('btnRefresh').addEventListener('click', refreshBalance);
function walletClear(){ state.walletAddress=null; addressEl.textContent='-'; balanceEl.textContent='-'; sendCard.classList.add('hidden'); explorer.href='#'; }

/* init on load */
window.addEventListener('load', ()=>{ const obj = loadLocal(); storeStatusEl.textContent = obj ? 'encrypted (local)' : 'none'; if(obj) document.getElementById('btnUnlock').classList.remove('hidden'); configureProvider(networkSel.value); });

</script>
</body>
</html>
  
